import useBaseUrl from '@docusaurus/useBaseUrl';

# JudeÈ›e, RomÃ¢nia (linie, geometrie simplificatÄƒ)

## Cod set de date

**`ro_admin_county_simplified_line`**

<figure style={{ textAlign: "center" }}>
  <img src={useBaseUrl('https://services.geo-spatial.org/data/thumbnails/administrative-boundaries/county/ro-admin-county-line.svg')} alt="Limite administrative - JudeÈ›e, RomÃ¢nia (linie, geometrie simplificatÄƒ)" />
</figure>

## Abordare practicÄƒ

Datele au fost obÈ›inute prin conversia geometriei stratului [Limite administrative - judeÈ›e, RomÃ¢nia (poligon, geometrie simplificatÄƒ)](https://services.geo-spatial.org/geonetwork/srv/eng/catalog.search#/metadata/1aebaee6-04e7-4a64-81c9-102060a57dc5) din poligon Ã®n linie È™i extragerea atributelor relevante.

Procesarea s-a fÄƒcut folosind un script (Bash - mediu *nix) ce este rulat dupÄƒ fiecare actualizare a datelor de la ANCPI. Scriptul utilizeazÄƒ mai multe biblioteci open source È™i utilitare de sistem: [mapshaper](https://mapshaper.org/), [GDAL](https://gdal.org), [curl](https://curl.se/), zip. Scriptul rezultat este prezentat Ã®n secÈ›iunea [Script ETL](#script-etl) È™i accesibil pentru descÄƒrcare pe pagina [GitHub](https://github.com/geospatialorg/ingestie-date/blob/main/publish_update_ro_admin_lau_simplified_line.sh) a geo-spatial.org.

## Prelucrarea datelor

### Conversia poligon Ã®n linie È™i adÄƒugarea cÃ¢mpurilor

Datele originale cu limita de tip linie a judeÈ›elor, de la ANCPI, conÈ›in o serie de atribute interesante precum `leftId`, `rightId`, `leftCounty` È™i `rightCounty`. TotuÈ™i, simplificarea geometriei acestora, independent de simplificarea geometriei stratului de tip poligon, ar fi dus la o nealiniere a geometriei celor douÄƒ straturi (datoritÄƒ modului Ã®n care funcÈ›ioneazÄƒ algoritmul de simplificare - a se vedea figura de mai jos). Conversia stratului [Limite administrative - judeÈ›e, RomÃ¢nia (poligon, geometrie simplificatÄƒ)](https://services.geo-spatial.org/geonetwork/srv/eng/catalog.search#/metadata/1aebaee6-04e7-4a64-81c9-102060a57dc5) Ã®n linie a creat o geometrie perfect aliniatÄƒ a celor douÄƒ straturi pe limitele comune. Deoarece nu vorbim despre o simplÄƒ conversie poligon Ã®n linie, pentru aceastrÄƒ operaÈ›iune s-a folosit o bibliotecÄƒ avansatÄƒ pentru lucrul cu date vectoriale: [Shapely](https://shapely.readthedocs.io/en/stable/), Ã®n jurul cÄƒreia s-a scris un [script dedicat Ã®n Python](https://github.com/geospatialorg/ingestie-date/blob/main/convert_ro_admin_county_simplified_polygon_to_line.py). Cu ajutorul acesteia, conversia s-a fÄƒcut Ã®n aÈ™a fel Ã®ncÃ¢t sÄƒ existe o singurÄƒ linie comunÄƒ Ã®ntre douÄƒ poligoane vecine sau limitele exterioare. De asemenea, au fost adÄƒugate urmÄƒtoarele cÃ¢mpuri, extrase din stratul de intrare:

* `leftId` - codul SIRUTA al regiunii vecine 1;
* `rightId` - codul SIRUTA al regiunii vecine 2;
* `leftCounty` - numele regiunii vecine 1;
* `rightCounty` - numele regiunii vecine 2;

<figure style={{ textAlign: "center" }}>
  <img src={useBaseUrl('/img/ghiduri/procesari-etl/administrative-boundaries/diferente_simplificare_independenta.jpg')} alt="Exemplu: simplificarea independentÄƒ a douÄƒ straturi cu laturi comune" />
  <figcaption><em>Exemplu: simplificarea independentÄƒ a douÄƒ straturi cu laturi comune.</em></figcaption>
</figure>

### Conversia Ã®n formate de fiÈ™ier populare

Datele au foct convertite Ã®n formatele de fiÈ™ier utilizate de geo-spatial.org pentru distribuirea de date vectoriale: `GeoPackage`, `Shapefile`, `Geoparquet`, `FlatGeobuf`, `GeoJSON`, `TopoJSON`, `KML`. Detalii despre motivaÈ›ia alegerii acestor formate È™i beneficiile fiecÄƒruia sunt prezentate Ã®n ghidul cu privire la date. De asemenea, pentru nevoi interne, datele au fost Ã®ncÄƒrcate Ã®n baza de date PostgreSQL/PostGIS.

### Publicare datelor

Datele au fost documentate Ã®n [Catalogul geo-spatial.org](https://services.geo-spatial.org/geonetwork/srv/eng/catalog.search#/metadata/d282526d-1b45-459f-8965-85250badcff9) È™i puse la dispoziÈ›ie pentru download/access prin protocolul HTTP È™i prin intermediul serviciilor standardizate OGC. Pentru mai multe detalii accesaÈ›i [Catalogul](https://services.geo-spatial.org/geonetwork/srv/eng/catalog.search#/metadata/d282526d-1b45-459f-8965-85250badcff9) È™i/sau secÈ›iunea <a href={useBaseUrl('descarcare/date/administrative-boundaries')}>DescÄƒrcare</a>. DefiniÈ›iile folosite pentru simbolizarea WMS a datelor au fost documentate Ã®n secÈ›iunea [Simbolizare SLD](#simbolizare-sld).

## Diagrama fluxului de lucru

<iframe
  src="https://geo-spatial.org/jsoncrack/editor/?json=https://geo-spatial.org/descrieri-etl-json/etl_ro_admin_county_simplified_line.json"
  width="100%"
  height="600"
  style={{ border: '1px solid #ccc', borderRadius: '8px' }}
  loading="lazy"
/>

<a
  href="https://geo-spatial.org/jsoncrack/editor/?json=https://geo-spatial.org/descrieri-etl-json/etl_ro_admin_county_simplified_line.json"
  target="_blank"
  rel="noopener noreferrer"
>
  Deschide diagrama Ã®ntr-o paginÄƒ separatÄƒ <i className="fa fa-external-link-alt" style={{ marginLeft: '0.3rem' }}></i>
</a>

## Script ETL

```bash title="publish_update_ro_admin_county_simplified_line.sh"
#!/usr/bin/zsh

##############################################################################################################
#ğŸ›  Publicare/actualizare JudeÈ›e, RomÃ¢nia (linie, geometrie simplificatÄƒ)
##############################################################################################################

#ğŸ› configuraÈ›ii

#ğŸ•¹ activare mediu Anaconda cu bibliotecile necesare pentru procesare
source /home/ubuntu/anaconda3/etc/profile.d/conda.sh
conda activate geo

#ğŸš definire cÄƒi date
county_data_path="/storage/volumes/geoserver-1-storage/administrative_boundaries/county"

#âš™ï¸ PostGIS
pg_host="localhost"
pg_port=5432
pg_user="user"
pg_db="geospatial"
pg_pass="pass"
pg_schema="romania"

#âš™ï¸ GeoServer
gs_url="http://localhost:8080/geoserver"
gs_user="user"
gs_pass="pass"
gs_workspace="administrative-boundaries"
gs_store="administrative-boundaries"
gs_layer_title="Limite administrative - judeÈ›e, RomÃ¢nia (linie, geometrie simplificatÄƒ)"
gs_layer_abstract="Set de date care conÈ›ine limitele oficiale ale judeÈ›elor din RomÃ¢nia, Ã®n format vectorial de tip poligon, procesat de comunitatea geo-spatial.org pe baza datelor publice furnizate de AgenÈ›ia NaÈ›ionalÄƒ de Cadastru È™i Publicitate ImobiliarÄƒ. Geometria originalÄƒ a fost simplificatÄƒ pentru scenariile Ã®n care este nevoie de o afiÈ™are rapidÄƒ a datelor sau reprezentarea la scÄƒri mici (ex: aplicaÈ›ii cartografice web)."
gs_layer_keywords=("RomÃ¢nia" "judeÈ›e" "limite administrative" "vector" "linie" "geometrie simplificatÄƒ")
gs_layer_metadata_link="https://services.geo-spatial.org/geonetwork/srv/eng/catalog.search#/metadata/d282526d-1b45-459f-8965-85250badcff9"
gs_layer_style="administrative-boundaries:ro_admin_county_simplified_line"

#âš™ï¸ Date
layer_name="ro_admin_county_simplified_line"

echo "
ğŸ›  Procesare JudeÈ›e, RomÃ¢nia (linie, geometrie simplificatÄƒ)
 "

 #ğŸ’¾ creare versiune GeoPackage
 echo "ğŸ’¾ creare versiune GeoPackage"
 if [ -f ${county_data_path}/${layer_name}.gpkg ]; then
     rm ${county_data_path}/${layer_name}.gpkg
 fi

 #ğŸ’¾ apeleazÄƒ script Python pentru conversie È™i crearea cÃ¢mpurilor leftName, leftId, respectiv rightName È™i rightId
 echo "ğŸ’¾ apeleazÄƒ script Python pentru conversie"
 python convert_ro_admin_county_simplified_polygon_to_line.py

 #ğŸ’¾ creare fiÈ™ier GeoPackage final
 echo "ğŸ’¾ creare fiÈ™ier GeoPackage final"
 ogr2ogr -of GPKG -lco FID=id -nln ${layer_name} -nlt MULTILINESTRING ${county_data_path}/${layer_name}.gpkg ${county_data_path}/${layer_name}_tmp.gpkg

 #ğŸ’¾ creare versiune Esri Shapefile
 echo "ğŸ’¾ creare versiune Esri Shapefile"
 if [ -f ${county_data_path}/${layer_name}.zip ]; then
     rm ${county_data_path}/${layer_name}.zip
 fi
 ogr2ogr -lco ENCODING=UTF-8 -nln ${layer_name} -dialect sqlite -sql "SELECT a.id AS id, * FROM ${layer_name} AS a" ${county_data_path}/${layer_name}.shp ${county_data_path}/${layer_name}.gpkg

 #ğŸ“¦ arhivare versiune shp
 echo "ğŸ“¦ arhivare versiune shp"
 zip -j ${county_data_path}/${layer_name}.zip ${county_data_path}/${layer_name}.dbf ${county_data_path}/${layer_name}.shp ${county_data_path}/${layer_name}.prj ${county_data_path}/${layer_name}.shx ${county_data_path}/${layer_name}.cpg

 #ğŸ’¾ creare versiune GeoJSON
 echo "ğŸ’¾ creare versiune GeoJSON"
 if [ -f ${county_data_path}/${layer_name}.geojson ]; then
     rm ${county_data_path}/${layer_name}.geojson
 fi
 ogr2ogr -of GeoJSON -t_srs EPSG:4326 -nln ${layer_name} -dialect sqlite -sql "SELECT a.id AS id, * FROM ${layer_name} AS a" ${county_data_path}/${layer_name}.geojson ${county_data_path}/${layer_name}.gpkg

 #ğŸ’¾ creare versiune FlatGeobuf
 echo "ğŸ’¾ creare versiune FlatGeobuf"
 if [ -f ${county_data_path}/${layer_name}.fgb ]; then
     rm ${county_data_path}/${layer_name}.fgb
 fi
 ogr2ogr -of FlatGeobuf -nlt MULTILINESTRING -nln ${layer_name} -dialect sqlite -sql "SELECT a.id AS id, * FROM ${layer_name} AS a" ${county_data_path}/${layer_name}.fgb ${county_data_path}/${layer_name}.gpkg

 #ğŸ’¾ creare versiune GeoParquet
 echo "ğŸ’¾ creare versiune GeoParquet"
 if [ -f ${county_data_path}/${layer_name}.parquet ]; then
     rm ${county_data_path}/${layer_name}.parquet
 fi
 ogr2ogr -of Parquet -nlt MULTILINESTRING -nln ${layer_name} -dialect sqlite -sql "SELECT a.id AS id, * FROM ${layer_name} AS a" ${county_data_path}/${layer_name}.parquet ${county_data_path}/${layer_name}.gpkg

 #ğŸ’¾ creare versiune KML
 echo "ğŸ’¾ creare versiune KML"
 if [ -f ${county_data_path}/${layer_name}.kml ]; then
     rm ${county_data_path}/${layer_name}.kml
 fi
 ogr2ogr -of KML -t_srs EPSG:4326 -dsco NameField=name ${county_data_path}/${layer_name}.kml ${county_data_path}/${layer_name}.gpkg

 #ğŸ’¾ creare versiune TopoJSON
 echo "ğŸ’¾ creare versiune TopoJSON"
 if [ -f ${county_data_path}/${layer_name}.topojson ]; then
     rm ${county_data_path}/${layer_name}.topojson
 fi
 mapshaper -i ${county_data_path}/${layer_name}.geojson -o format=topojson ${county_data_path}/${layer_name}.topojson

#ğŸ’¾ actualizarea setului de date Ã®n baza de date PostGIS
echo "ğŸ’¾ actualizarea setului de date Ã®n baza de date PostGIS"
ogr2ogr -of PostgreSQL PG:"host=${pg_host} port=${pg_port} user=${pg_user} dbname=${pg_db} password=${pg_pass}" -lco schema=${pg_schema} -lco GEOMETRY_NAME=geom -lco overwrite=yes ${county_data_path}/${layer_name}.gpkg ${layer_name} -skipfailures -overwrite

#ğŸ–‡ indexare date PostGIS
psql -h ${pg_host} -p ${pg_port} -U ${pg_user} -d ${pg_db} -c "
CREATE INDEX ${layer_name}_geom_idx ON romania.${layer_name} USING GIST (geom);
CLUSTER romania.${layer_name} USING ${layer_name}_geom_idx;"

#ğŸ’¾ publicarea/actualizarea serviciilor de date
echo "ğŸ’¾ publicarea/actualizarea serviciilor de date"

#âŒ È™tergere strat existent (dacÄƒ existÄƒ)
echo "ğŸ” Verificare dacÄƒ existÄƒ stratul."
HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -u $gs_user:$gs_pass \
  "${gs_url}/rest/layers/${gs_workspace}:${layer_name}.xml")

if [ "$HTTP_STATUS" == "200" ]; then
    echo "âš ï¸  Stratul existÄƒ. Se È™terge."
    curl -s -u $gs_user:$gs_pass -XDELETE \
      "${gs_url}/rest/layers/${gs_workspace}:${layer_name}?recurse=true"
    echo "ğŸ—‘ï¸  Stratul a fost È™ters."
else
    echo "âœ… Nu existÄƒ strat cu acest nume."
fi

#ğŸ’¾ creare strat
echo "â• Creare strat ${layer_name}"
curl -s -u $gs_user:$gs_pass -XPOST -H "Content-type: text/xml" \
  -d "<featureType>
         <name>${layer_name}</name>
         <nativeName>${layer_name}</nativeName>
         <title>${gs_layer_title}</title>
         <abstract>${gs_layer_abstract}</abstract>
     </featureType>" \
  "${gs_url}/rest/workspaces/${gs_workspace}/datastores/${gs_store}/featuretypes"

#ğŸ’¾ adÄƒugare detalii suplimentare (keywords È™i metadata link)
echo "ğŸ“ Actualizare metadate"
keywords_xml=""
for keyword in "${gs_layer_keywords[@]}"; do
    keywords_xml+="<string>${keyword}</string>"
done

curl -s -u $gs_user:$gs_pass -XPUT -H "Content-type: text/xml" \
-d "<featureType>
        <keywords>
            ${keywords_xml}
        </keywords>
        <metadataLinks>
            <metadataLink>
                <type>text/xml</type>
                <metadataType>ISO19115:2003</metadataType>
                <content>${gs_layer_metadata_link}</content>
            </metadataLink>
        </metadataLinks>
    </featureType>" \
"${gs_url}/rest/workspaces/${gs_workspace}/datastores/${gs_store}/featuretypes/${layer_name}"

#ğŸ’¾ Setare stil implicit + ataÈ™are stil suplimentar
echo "ğŸ¨ Setare stil implicit + ataÈ™are stil suplimentar..."
curl -s -u $gs_user:$gs_pass -XPUT -H "Content-type: text/xml" \
  -d "<layer>
         <defaultStyle>
             <name>${gs_layer_style##*:}</name>
         </defaultStyle>
     </layer>" \
  "${gs_url}/rest/layers/${gs_workspace}:${layer_name}"

echo "âœ… Stratul ${layer_name} a fost adÄƒugat È™i configurat cu succes Ã®n GeoServer."

#ğŸ—‘ï¸ È˜tergere fiÈ™iere intermediare
echo "ğŸ—‘ï¸ È˜tergere fiÈ™iere Shapefile"
rm ${county_data_path}/${layer_name}.dbf ${county_data_path}/${layer_name}.shp ${county_data_path}/${layer_name}.prj ${county_data_path}/${layer_name}.shx ${county_data_path}/${layer_name}.cpg ${county_data_path}/${layer_name}_tmp.gpkg
```
Script accesibil È™i pe [GitHub](https://github.com/geospatialorg/ingestie-date/blob/main/publish_update_ro_admin_county_simplified_line.sh).

```python title="convert_ro_admin_county_simplified_polygon_to_line.py"
import json
from collections import defaultdict
from osgeo import ogr
from shapely.geometry import shape, LineString
from shapely.ops import unary_union

# ActivÄƒm excepÈ›iile pentru debugare
ogr.UseExceptions()

# === CONFIGURARE ===
input_file = "/storage/volumes/geoserver-1-storage/administrative_boundaries/county/ro_admin_county_simplified_polygon.gpkg"
input_layer_name = "ro_admin_county_simplified_polygon"
field_name_name = "name"
field_name_id = "countyCode"
output_file = "/storage/volumes/geoserver-1-storage/administrative_boundaries/county/ro_admin_county_simplified_line_tmp.gpkg"
output_layer_name = "ro_admin_county_simplified_line_tmp"

# === Citim poligoanele È™i preluÄƒm valoarea version ===
source = ogr.Open(input_file)
layer = source.GetLayerByName(input_layer_name)
features = list(layer)

# PreluÄƒm valoarea 'version' din primul poligon (identicÄƒ Ã®n toate)
version_value = features[0].GetField("version")

# DicÈ›ionar cu segmentele normalizate È™i vecinii lor
segment_dict = defaultdict(list)

def normalize_segment(p1, p2):
    return (p1, p2) if p1 <= p2 else (p2, p1)

for feat in features:
    geom = shape(json.loads(feat.geometry().ExportToJson()))
    name = feat.GetField(field_name_name)
    code = feat.GetField(field_name_id)
    boundary = geom.boundary

    if boundary.geom_type == "LineString":
        coords = list(boundary.coords)
        for i in range(len(coords) - 1):
            seg = normalize_segment(coords[i], coords[i + 1])
            segment_dict[seg].append((name, code))
    elif boundary.geom_type == "MultiLineString":
        for part in boundary.geoms:
            coords = list(part.coords)
            for i in range(len(coords) - 1):
                seg = normalize_segment(coords[i], coords[i + 1])
                segment_dict[seg].append((name, code))

# GrupÄƒm segmentele dupÄƒ perechi de vecini
neighbor_segments = defaultdict(list)

for (p1, p2), neighbors in segment_dict.items():
    geom = LineString([p1, p2])
    if len(neighbors) == 1:
        key = (neighbors[0], None)
    elif len(neighbors) == 2:
        key = tuple(sorted(neighbors))
    else:
        continue
    neighbor_segments[key].append(geom)

# === CreÄƒm fiÈ™ierul GeoPackage de ieÈ™ire ===
driver = ogr.GetDriverByName("GPKG")
driver.DeleteDataSource(output_file)
out_ds = driver.CreateDataSource(output_file)

srs = ogr.osr.SpatialReference()
srs.ImportFromEPSG(3844)

out_layer = out_ds.CreateLayer(output_layer_name, srs, geom_type=ogr.wkbMultiLineString)

# CÃ®mpuri: vecini + version
out_layer.CreateField(ogr.FieldDefn("leftCounty", ogr.OFTString))
out_layer.CreateField(ogr.FieldDefn("leftId", ogr.OFTInteger))
out_layer.CreateField(ogr.FieldDefn("rightCounty", ogr.OFTString))
out_layer.CreateField(ogr.FieldDefn("rightId", ogr.OFTInteger))

# NotÄƒ: cÃ¢mpul 'version' este salvat ca text (nu OFTDate), deoarece:
# - ogr + GPKG nu salveazÄƒ corect valorile OFTDate din Python
# - varianta string este stabilÄƒ, vizibilÄƒ È™i portabilÄƒ
out_layer.CreateField(ogr.FieldDefn("version", ogr.OFTString))

# Scriem segmentele cu atribute
for (left, right), seg_list in neighbor_segments.items():
    multi = unary_union(seg_list)
    if multi.is_empty:
        continue

    feat = ogr.Feature(out_layer.GetLayerDefn())
    if left:
        feat.SetField("leftCounty", left[0])
        feat.SetField("leftId", left[1])
    if right:
        feat.SetField("rightCounty", right[0])
        feat.SetField("rightId", right[1])

    # SetÄƒm valoarea version ca È™ir (ex: '2025-01-01')
    feat.SetField("version", str(version_value))

    geom = ogr.CreateGeometryFromWkb(multi.wkb)
    feat.SetGeometry(geom)
    out_layer.CreateFeature(feat)
    feat = None

# FinalizÄƒm
out_ds = None
source = None

print(f"âœ… FiÈ™ierul '{output_file}' a fost generat cu succes.")

```
Script accesibil È™i pe [GitHub](https://github.com/geospatialorg/ingestie-date/blob/main/convert_ro_admin_county_simplified_polygon_to_line.py).

## Simbolizare SLD

### Simbolizare SLD implicitÄƒ

```xml title="ro_admin_county_simplified_line_labels.sld"
<?xml version="1.0" encoding="UTF-8"?>
<StyledLayerDescriptor xmlns="http://www.opengis.net/sld" xmlns:ogc="http://www.opengis.net/ogc" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.opengis.net/sld http://schemas.opengis.net/sld/1.1.0/StyledLayerDescriptor.xsd" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:se="http://www.opengis.net/se" version="1.1.0">
  <NamedLayer>
  <se:Name>JudeÈ›e</se:Name>
  <UserStyle>
    <se:Name>LimitÄƒ judeÈ›</se:Name>
    <se:FeatureTypeStyle>
      <se:Rule>
        <se:Name>LimitÄƒ judeÈ›</se:Name>
          <se:PolygonSymbolizer>
            <se:Stroke>
              <se:SvgParameter name="stroke">#b71540</se:SvgParameter>
              <se:SvgParameter name="stroke-width">2</se:SvgParameter>
              <se:SvgParameter name="stroke-linejoin">bevel</se:SvgParameter>
            </se:Stroke>
          </se:PolygonSymbolizer>
        </se:Rule>
      </se:FeatureTypeStyle>
    </UserStyle>
  </NamedLayer>
</StyledLayerDescriptor>
```
FiÈ™ier accesibil È™i pe [GitHub](https://github.com/geospatialorg/simbolizare/blob/main/sld/administrative-boundaries/ro_admin_county_simplified_line.sld).
