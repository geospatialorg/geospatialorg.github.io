import useBaseUrl from '@docusaurus/useBaseUrl';

# UAT, RomÃ¢nia (linie)

## Cod set de date

**`ro_admin_lau_line`**

<figure style={{ textAlign: "center" }}>
  <img src={useBaseUrl('https://services.geo-spatial.org/data/thumbnails/administrative-boundaries/lau/ro-admin-lau-line.svg')} alt="Limite administrative - UAT, RomÃ¢nia (poligon)" />
</figure>

## Abordare practicÄƒ

Limitele unitÄƒÈ›ilor administrativ teritoriale (UAT) din RomÃ¢nia, format vectorial/linie, au fost descÄƒrcate de pe [geoportalul ANCPI](https://geoportal.ancpi.ro/portal/apps/webappviewer/index.html?id=faeba2d173374445b1f13512bd477bb2) Ã®n format Shapefile. Ulterior, au fost trecute printr-o procedurÄƒ automatÄƒ de Ã®mbunÄƒtÄƒÈ›ire folosind un script (Bash - mediu *nix) ce este rulat dupÄƒ fiecare actualizare a datelor de la ANCPI. Pentru paÈ™ii de procesare, scriptul utilizeazÄƒ mai multe biblioteci open source È™i utilitare de sistem: [GDAL](https://gdal.org), [mapshaper](https://mapshaper.org/), [csvkit](https://csvkit.readthedocs.io/en/latest/), [mdb-tools](https://mdbtools.github.io/), [sed](https://www.gnu.org/software/sed/manual/sed.html), [awk](https://www.gnu.org/software/gawk/manual/gawk.html). Scriptul rezultat este prezentat Ã®n secÈ›iunea [Script ETL](#script-etl) È™i accesibil pentru descÄƒrcare pe pagina [GitHub](https://github.com/geospatialorg/ingestie-date/blob/main/publish_update_ro_admin_country_line.sh) a geo-spatial.org.

## Prelucrarea datelor

### Definirea corectÄƒ a proiecÈ›iei

Datele au venit cu o definiÈ›ie nestandardizatÄƒ a proiecÈ›iei:

>PROJCRS["Romania_double_stereo",BASEGEOGCRS["Pulkovo 1942",DATUM["Pulkovo 1942",ELLIPSOID["Krassowsky 1940",6378245,298.3,LENGTHUNIT["metre",1]],ID["EPSG",6284]],PRIMEM["Greenwich",0,ANGLEUNIT["Degree",0.0174532925199433]]],CONVERSION["unnamed",METHOD["Oblique Stereographic",ID["EPSG",9809]],PARAMETER["Latitude of natural origin",46,ANGLEUNIT["Degree",0.0174532925199433],ID["EPSG",8801]],PARAMETER["Longitude of natural origin",25,ANGLEUNIT["Degree",0.0174532925199433],ID["EPSG",8802]],PARAMETER["Scale factor at natural origin",0.99975,SCALEUNIT["unity",1],ID["EPSG",8805]],PARAMETER["False easting",500000,LENGTHUNIT["metre",1],ID["EPSG",8806]],PARAMETER["False northing",500000,LENGTHUNIT["metre",1],ID["EPSG",8807]]],CS[Cartesian,2],AXIS["(E)",east,ORDER[1],LENGTHUNIT["metre",1,ID["EPSG",9001]]],AXIS["(N)",north,ORDER[2],LENGTHUNIT["metre",1,ID["EPSG",9001]]]]

Aceasta a fost Ã®nlocuitÄƒ cu [EPSG:3844](https://epsg.io/3844).

### Eliminarea cÃ¢mpurilor cu informaÈ›ie redundantÄƒ

O serie din cÃ¢mpuri au fost considerate neimportante pentru utilizatorul obiÈ™nuit: `IFCID`, `localId`, `namespace`, `country`, `versionId`, `natLevel`, `tehnStatus`, `endVersion`, `Shape_Leng`. Aceste cÃ¢mpuri, cum ar fi `namespace`, pot avea importanÈ›a lor Ã®n demersuri precum Directiva INSPIRE dar, din punct de vedere practic, cÃ¢nd nu sunt exploatate Ã®ntr-un context de interoperabilitate cu date la nivel european, dar care, altfel, doar Ã®ncarcÄƒ inutil setul de date (au aceeaÈ™i valoare pentru toate entitÄƒÈ›ile din setul de date).

### AdÄƒugarea de cÃ¢mpuri noi

Din nomenclatorul [SIRUTA](http://80.96.186.4:81/senin/classifications.htm), publicat de [Institutul NaÈ›ional de StatisticÄƒ](https://insse.ro), au fost adÄƒugate o serie de cÃ¢mpuri suplimentare:

* `leftId` - codul SIRUTA al UAT-ului vecin 1 (extras din cÃ¢mpul original `localId`);
* `rightId` - codul SIRUTA al UAT-ului vecin 2 (extras din cÃ¢mpul original `localId`);
* `countyCode` - codul SIRUTA al judeÈ›ului;
* `leftLAU` - numele UAT-ului vecin 1 (obÈ›inut prin join folosind codul SIRUTA);
* `rightLAU` - numele UAT-ului vecin 2 (obÈ›inut prin join folosind codul SIRUTA);

:::warning[AtenÈ›ie!]

CÃ¢mpurile `leftId` È™i `leftLAU` sau `rightId` È™i `rightLAU` lipsesc Ã®n cazul UAT-urile de la frontierÄƒ/Marea NeagrÄƒ.

:::

### Conversia Ã®n formate de fiÈ™ier populare

Datele au foct convertite Ã®n formatele de fiÈ™ier utilizate de geo-spatial.org pentru distribuirea de date vectoriale: `GeoPackage`, `Shapefile`, `Geoparquet`, `FlatGeobuf`, `GeoJSON`, `TopoJSON`, `KML`. Detalii despre motivaÈ›ia alegerii acestor formate È™i beneficiile fiecÄƒruia sunt prezentate Ã®n ghidul cu privire la date. De asemenea, pentru nevoi interne, datele au fost Ã®ncÄƒrcate Ã®n baza de date PostgreSQL/PostGIS.

### Publicare datelor

Datele au fost documentate Ã®n [Catalogul geo-spatial.org](https://services.geo-spatial.org/geonetwork/srv/eng/catalog.search#/metadata/a824c22d-6243-410e-a89a-d7d11199c077) È™i puse la dispoziÈ›ie pentru download/access prin protocolul HTTP È™i prin intermediul serviciilor standardizate OGC. Pentru mai multe detalii accesaÈ›i [Catalogul](https://services.geo-spatial.org/geonetwork/srv/eng/catalog.search#/metadata/a824c22d-6243-410e-a89a-d7d11199c077) È™i/sau secÈ›iunea <a href={useBaseUrl('descarcare/date/administrative-boundaries')}>DescÄƒrcare</a>.

## Script ETL

```bash title="publish_update_ro_admin_country_line.sh"
#!/usr/bin/zsh

##############################################################################################################
#ğŸ›  Publicare/actualizare frontierÄƒ linie
##############################################################################################################

#ğŸ› configuraÈ›ii

#ğŸ•¹ activare mediu Anaconda cu bibliotecile necesare pentru procesare
source /home/ubuntu/anaconda3/etc/profile.d/conda.sh
conda activate geo

#ğŸš definire cÄƒi date
ancpi_data_path="/storage/volumes/geoserver-1-storage/brute/institutii_romania/ancpi/limite_administrative"
out_data_path="/storage/volumes/geoserver-1-storage/administrative_boundaries/country"

#âš™ï¸ PostGIS
pg_host="localhost"
pg_port=5432
pg_user="user"
pg_db="geospatial"
pg_pass="pass"
pg_schema="romania"

#âš™ï¸ GeoServer
gs_url="http://localhost:8080/geoserver"
gs_user="user"
gs_pass="pass"
gs_workspace="administrative-boundaries"
gs_store="administrative-boundaries"
gs_layer_title="Limite administrative - frontiera de stat, RomÃ¢nia (linie)"
gs_layer_abstract="Acest set de date conÈ›ine limitele oficiale ale teritoriului RomÃ¢niei, Ã®n format vectorial de tip linie, procesat de comunitatea geo-spatial.org pe baza datelor publice furnizate de AgenÈ›ia NaÈ›ionalÄƒ de Cadastru È™i Publicitate ImobiliarÄƒ."
gs_layer_keywords=("RomÃ¢nia" "frontiera de stat" "limite administrative" "vector" "linie")
gs_layer_metadata_link="https://services.geo-spatial.org/geonetwork/srv/eng/catalog.search#/metadata/a824c22d-6243-410e-a89a-d7d11199c077"
gs_layer_style="ro_admin_country_line"

#âš™ï¸ Date
layer_name="ro_admin_country_line"

echo "
ğŸ›  Procesare frontierÄƒ linie
"

#ğŸ’¾ creare versiune GPKG
echo "ğŸ’¾ creare versiune GPKG"
if [ -f ${out_data_path}/${layer_name}.gpkg ]; then
    rm ${out_data_path}/${layer_name}.gpkg
fi
ogr2ogr -of GPKG -lco FID=id -a_srs "EPSG:3844" -nln ${layer_name} -dialect sqlite -sql "SELECT a.localId AS border, a.beginVers AS version, a.Geometry AS geometry FROM Limita_administrativa_tara AS a" ${out_data_path}/${layer_name}.gpkg ${ancpi_data_path}/Limita_administrativa_tara.shp

#ğŸ’¾ creare versiune Shapefile
echo "ğŸ’¾ creare versiune Shapefile"
if [ -f ${out_data_path}/${layer_name}.zip ]; then
    rm ${out_data_path}/${layer_name}.zip
fi
ogr2ogr -lco ENCODING=UTF-8 -nln ${layer_name} -dialect sqlite -sql "SELECT a.id AS id, * FROM ${layer_name} AS a" ${out_data_path}/${layer_name}.shp ${out_data_path}/${layer_name}.gpkg

#ğŸ“¦ arhivare fiÈ™iere shp
echo "ğŸ“¦ arhivare fiÈ™iere shp"
zip -j ${out_data_path}/${layer_name}.zip ${out_data_path}/${layer_name}.dbf ${out_data_path}/${layer_name}.shp ${out_data_path}/${layer_name}.prj ${out_data_path}/${layer_name}.shx ${out_data_path}/${layer_name}.cpg

#ğŸ’¾ creare versiune FlatGeobuf
echo "ğŸ’¾ creare versiune FlatGeobuf"
if [ -f ${out_data_path}/${layer_name}.fgb ]; then
    rm ${out_data_path}/${layer_name}.fgb
fi
ogr2ogr -of FlatGeobuf -nln ${layer_name} -dialect sqlite -sql "SELECT a.id AS id, * FROM ${layer_name} AS a" -nlt MULTILINESTRING ${out_data_path}/${layer_name}.fgb ${out_data_path}/${layer_name}.gpkg

#ğŸ’¾ creare versiune GeoParquet
echo "ğŸ’¾ creare versiune GeoParquet"
if [ -f ${out_data_path}/${layer_name}.parquet ]; then
    rm ${out_data_path}/${layer_name}.parquet
fi
ogr2ogr -of Parquet -nlt MULTILINESTRING -nln ${layer_name} -dialect sqlite -sql "SELECT a.id AS id, * FROM ${layer_name} AS a" ${out_data_path}/${layer_name}.parquet ${out_data_path}/${layer_name}.gpkg

#ğŸ’¾ creare versiune GeoJSON
echo "ğŸ’¾ creare versiune GeoJSON"
if [ -f ${out_data_path}/${layer_name}.geojson ]; then
    rm ${out_data_path}/${layer_name}.geojson
fi
ogr2ogr -of GeoJSON -t_srs EPSG:4326 -nln ${layer_name} -dialect sqlite -sql "SELECT a.id AS id, * FROM ${layer_name} AS a" ${out_data_path}/${layer_name}.geojson ${out_data_path}/${layer_name}.gpkg

#ğŸ’¾ creare versiune KML
echo "ğŸ’¾ creare versiune KML"
if [ -f ${out_data_path}/${layer_name}.kml ]; then
    rm ${out_data_path}/${layer_name}.kml
fi
ogr2ogr -of KML -t_srs EPSG:4326 -dsco NameField=name ${out_data_path}/${layer_name}.kml ${out_data_path}/${layer_name}.gpkg

#ğŸ’¾ creare versiune TopoJSON
echo "ğŸ’¾ creare versiune TopoJSON"
if [ -f ${out_data_path}/${layer_name}.topojson ]; then
    rm ${out_data_path}/${layer_name}.topojson
fi
mapshaper -i ${out_data_path}/${layer_name}.geojson -o format=topojson ${out_data_path}/${layer_name}.topojson

#ğŸ’¾ actualizarea setului de date Ã®n baza de date PostGIS
echo "ğŸ’¾ actualizarea setului de date Ã®n baza de date PostGIS"
ogr2ogr -of PostgreSQL PG:"host=${pg_host} port=${pg_port} user=${pg_user} dbname=${pg_db} password=${pg_pass}" -lco schema=${pg_schema} -lco GEOMETRY_NAME=geom -lco overwrite=yes ${out_data_path}/${layer_name}.gpkg ${layer_name} -skipfailures -overwrite

#ğŸ–‡ indexare date PostGIS
psql -h ${pg_host} -p ${pg_port} -U ${pg_user} -d ${pg_db} -c "
CREATE INDEX ${layer_name}_geom_idx ON romania.${layer_name} USING GIST (geom);
CLUSTER romania.${layer_name} USING ${layer_name}_geom_idx;"

#ğŸ’¾ publicarea/actualizarea serviciilor de date
echo "ğŸ’¾ publicarea/actualizarea serviciilor de date"

#âŒ È™tergere strat existent (dacÄƒ existÄƒ)
echo "ğŸ” Verificare dacÄƒ existÄƒ stratul."
HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -u $gs_user:$gs_pass \
  "${gs_url}/rest/layers/${gs_workspace}:${layer_name}.xml")

if [ "$HTTP_STATUS" == "200" ]; then
    echo "âš ï¸  Stratul existÄƒ. Se È™terge."
    curl -s -u $gs_user:$gs_pass -XDELETE \
      "${gs_url}/rest/layers/${gs_workspace}:${layer_name}?recurse=true"
    echo "ğŸ—‘ï¸  Stratul a fost È™ters."
else
    echo "âœ… Nu existÄƒ strat cu acest nume."
fi

#ğŸ’¾ creare strat
echo "â• Creare strat ${layer_name}"
curl -s -u $gs_user:$gs_pass -XPOST -H "Content-type: text/xml" \
  -d "<featureType>
         <name>${layer_name}</name>
         <nativeName>${layer_name}</nativeName>
         <title>${gs_layer_title}</title>
         <abstract>${gs_layer_abstract}</abstract>
     </featureType>" \
  "${gs_url}/rest/workspaces/${gs_workspace}/datastores/${gs_store}/featuretypes"

#ğŸ’¾ adÄƒugare detalii suplimentare (keywords È™i metadata link)
echo "ğŸ“ Actualizare metadate"
keywords_xml=""
for keyword in "${gs_layer_keywords[@]}"; do
    keywords_xml+="<string>${keyword}</string>"
done

curl -s -u $gs_user:$gs_pass -XPUT -H "Content-type: text/xml" \
-d "<featureType>
        <keywords>
            ${keywords_xml}
        </keywords>
        <metadataLinks>
            <metadataLink>
                <type>text/xml</type>
                <metadataType>ISO19115:2003</metadataType>
                <content>${gs_layer_metadata_link}</content>
            </metadataLink>
        </metadataLinks>
    </featureType>" \
"${gs_url}/rest/workspaces/${gs_workspace}/datastores/${gs_store}/featuretypes/${layer_name}"

#ğŸ’¾ Setare stil implicit
echo "ğŸ¨ Setare stil ${gs_layer_style}..."
curl -s -u $gs_user:$gs_pass -XPUT -H "Content-type: text/xml" \
  -d "<layer>
         <defaultStyle>
             <name>${gs_layer_style}</name>
         </defaultStyle>
     </layer>" \
  "${gs_url}/rest/layers/${gs_workspace}:${layer_name}"

echo "âœ… Stratul ${layer_name} a fost adÄƒugat È™i configurat cu succes Ã®n GeoServer."

#ğŸ—‘ï¸ È˜tergere fiÈ™iere intermediare
echo "ğŸ—‘ï¸ È˜tergere fiÈ™iere Shapefile"
rm ${out_data_path}/${layer_name}.dbf ${out_data_path}/${layer_name}.shp ${out_data_path}/${layer_name}.prj ${out_data_path}/${layer_name}.shx ${out_data_path}/${layer_name}.cpg

```
